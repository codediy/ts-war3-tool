
<html>
<head>
<title>JASS Manual: Global Declarations</title>
<link rel="stylesheet" href="style.css" type="text/css">
</head>

<body>



<p><strong>Global Declarations</strong>

<p>We define a JASS program or <em>script</em> to be a series of
<tt>*.ai</tt> and <tt>*.j</tt> files that make up either a runnable
map trigger script or an AI script.

<ul>
<li>
A <em>map script</em> is responsible
for initializing <em>callbacks</em> or triggers that are executed when
certain events occur within a game. In addition, the map script generally
initializes the map by creating the initial units and setting the initial
properties of the map. The files that compose a map script are
<tt>common.j</tt>, <tt>Blizzard.j</tt>, and <tt>war3map.j</tt>
(loaded in that order). 
<li>
An <em>AI script</em> is responsible for the continuous execution of building, 
training, and attacking commands by a single computer player within a game. The
files that compose an AI script are <tt>common.j</tt>, <tt>common.ai</tt>,
and a user-defined AI script (e.g., <tt>human.ai</tt>, <tt>elf.ai</tt>, etc.).
</ul>

<p>
<tt>common.j</tt>, <tt>Blizzard.j</tt>, and <tt>common.ai</tt> are located
in the <tt>Scripts/</tt> directory in the MPQ, but they can be overridded
by placing them within a <tt>*.w3m</tt>.
We call the declarations in these
files <em>library</em> functions (and variables) since they are loaded with
every map/AI script respectively. See <a href="library.shtml">Library
Functions</a> for more information.

<p>
<tt>war3map.j</tt> is located in each <tt>*.w3m</tt> map file. It is
automatically generated by the World Editor each time you save your map
(so if you edit it directly, it will be overwritten when you edit your
map again in the World Editor). However, you can edit segments of it
directly in the World Editor by creating a trigger and using the
"Convert to Custom Text" option in the "Edit" menu. 

<p>In addition, to quote Brett Wood, "In the Trigger Editor [of TFT], 
if you select 
the root of the tree on the left (the map name at the top), you can enter 
arbitrary custom script code on the right.  This script code is included in 
the map script right before all of the trigger code. 
This is a good place to write custom functions, which can then be used by 
multiple triggers.  Theoretically, you could even do all of your scripting 
here, and not make any 'regular triggers' (although you'd probably still 
need at least one to call into your script code somewhere)."

<p>Note that variables
you create with the Variable Editor in the World Editor are global
variables. However, when the World Editor actually creates the map script,
it will transform the variable names by prefixing <code>udg_</code> and
replacing spaces with underscores (<code>_</code>). For example, if you
create a variable caled <code>my unit group</code> in the Variable Editor,
you would actually refer to it as <code>udg_my_unit_group</code>
in the map script.

<p>A JASS script consists of a series of 
<em>global declarations</em>. Global declarations consist of:

<ul>
<li><em><a href="#typedef">type definitions</a></em>
<li><em><a href="#globals">global variables</a></em>
<li><em><a href="#native">native functions</a></em>
<li><em><a href="#functions">user defined functions</a></em>
</ul>

<p>
In each file, type declarations and global variables must be declared
<strong>before</strong> all user-defined
function declarations. In all cases, you can
not refer to declarations made after the reference (i.e., you must declare
a type on a line before you extend it; you must declare a global variable
on a line before you refer to it in an expression; and you must declare a
function on a line before you call it, with the exception that a function
may call itself).
Each declaration begins on a new line (some span multiple lines).

<p><strong><a name="typedef">Type Definitions</a></strong>

<p>JASS allows user-defined types to be declared with the following, where
<code>new_type</code> is the user type being declared and 
<code>parent_type</code> is the previously defined type that this type
is a subtype of. See <a href="types.shtml">Types</a> for more information.

<pre class="source">
<span class="keyword">type</span> <span class="hi">new_type</span> <span class="keyword">extends</span> <span class="hi">parent_type</span>
</pre>

<p>In each file, these must be declared before all functions.

<p><strong><a name="globals">Global Variables</a></strong>

<p>There are two scopes for variables in JASS: global and function. Variables
declared in global scope can be referenced from any function; variables
declared in a function and function parameters can only be referenced within
that function. Global variables are declared in the following manner:

<pre class="source">
<span class="keyword">globals</span>
     <span class="hi">type name</span> <em>= <span class="hi">expression</span></em>
     <span class="hi">type name</span> <em>= <span class="hi">expression</span></em>
     <span class="hi">type name</span> <em>= <span class="hi">expression</span></em>
     <span class="hi">...</span>
<span class="keyword">endglobals</span>
</pre>

<p>All declarations are enclosed within a <code>globals</code> block, and each
is on a separate line. <code>type</code> is the type of the variable. This
may either be a basic type or an array of basic types, declared as 
<code><span class="hi">type</span> array <span class="hi">name</span></code>. 
See <a href="types.shtml">Types</a> for more information.
<code>name</code> is the name of the variable and <code>expression</code> is
an optional value to initially assign the variable.
See <a href="expressions.shtml">Expressions</a> for more information.

<p>A non-array variable declaration may be prefixed with 
<code>constant</code>. This means the variable contains a value that can 
not be changed later (e.g., you can not use <code>set</code> on it).
Hence, constant variables must be initialized with a value.

<p>For example, here is an integer variable initialized to the value 10:

<pre class="source">
     <span class="type">integer</span> numberOfStuff = 10
</pre>

<p>A constant integer variable initialized to the product of
two other variables:

<pre class="source">
<span class="keyword">     constant</span> <span class="type">integer</span> howManyUnits = numberOfGrunts * numberOfAttacks
</pre>

<p>A string variable that is not initialized:

<pre class="source">
     <span class="type">string</span> someMessage
</pre>

<p>An array of units. Arrays can not be initialized.

<pre class="source">
     unit <span class="type">array</span> listOfUnits
</pre>

<p>In each file, the <code>globals</code> block must be declared before all
functions and there can only be <strong>one</strong> globals block.

<p><strong><a name="native">Native Functions</a></strong>

<p>Native functions are functions that are implemented within the Warcraft III
engine. They form the API which the game exports to JASS programmers. Unless
you have access to Warcraft III's source code, you probably will not be
defining a new native function, but you will probably call them. Their
prototypes are declared in <tt>common.j</tt>, <tt>common.ai</tt>, and
<tt>Blizzard.j</tt>. The prototypes look like the following:

<pre class="source">
<span class="keyword">native</span> <span class="hi">func_name</span> <span class="keyword">takes</span> <span class="hi">param_list</span> <span class="keyword">returns</span> <span class="hi">return_type</span>
</pre>

Where <code>func_name</code> is the name of the function, 
<code>param_list</code> is an ordered, comma separated list of argument 
types that must
be passed to the function when called, and <code>return_type</code>
is the type of the return value of the function, if any. If
<code>param_list</code> is <code>nothing</code> then the function takes
no parameters; if the <code>return_type</code> is <code>nothing</code> then
the function does not return a value and hence can not be used as a valid
expression.

<p>For example, a native function that takes a string and
a unit and has no return value:

<pre class="source">
<span class="keyword">native</span> MakeUnitTalk <span class="keyword">takes</span> <span class="type">string</span> whatToSay, unit targetUnit <span class="keyword">returns</span> <span class="type">nothing</span>
</pre>

<p>Native functions may be declared with <code>constant</code> as a prefix.
See <a href="functions.shtml">Functions</a> for more information.

<p><strong><a name="functions">User-Defined Functions</a></strong>

<p>A user-defined function is similar to a native function but has a body
consisting of its implementation (e.g., what it does). It is declared
in the following manner:

<pre class="source">
<span class="keyword">function</span> <span class="hi">func_name</span> <span class="keyword">takes</span> <span class="hi">param_list</span> <span class="keyword">returns</span> <span class="hi">return_type</span>
     <em class="hi">variable_declaration</em>
     <em class="hi">variable_declaration</em>
     <span class="hi">...</span>
     <em class="hi">statement</em>
     <em class="hi">statement</em>
     <em class="hi">statement</em>
     <span class="hi">...</span>
<span class="keyword">endfunction</span>
</pre>

<p>The prototype values are the same as with native functions. The function
body consists of a series of local variable declarations followed by
a series of statements (either of which may be empty). See
<a href="functions.shtml">Functions</a> for more information.

<p>Functions may also be declared with <code>constant</code> as a prefix.



</body>
</html>
